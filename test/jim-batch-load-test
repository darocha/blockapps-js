#!/usr/bin/env node
var Promise = require("bluebird")
var lib = require("..")
lib.handlers.enable = true
lib.setProfile("ethereum-frontier", "https://strato-scale1.blockapps.net/strato-api")

var privkey = lib.ethbase.Crypto.PrivateKey('267579485e8f1f62d74836fabb15974a576fba3e3e35b0319434203a07d70fc6');
//var privkey = lib.ethbase.Crypto.PrivateKey.random()
var faucet = lib.routes.faucet(privkey.toAddress())

var size = 100;
var gapMS = 10000;

var timesObj = { arr: [] };
process.on('SIGQUIT', function() {
  var times = timesObj.arr;
  timesObj.arr = [];

  process.stdout.write("\n\n")

  process.stdout.write("Transmission time stats:")
  doStats(times, "s");

  process.stdout.write("Transmission TPS stats:")
  doStats(times.map(function(time) { return size/time; }), "tx/s");

  process.stdout.write("Total TPS stats:")
  doStats(times.map(function(time) { return size/(time + gapMS / 1000); }), "tx/s");
});

timeBatchSizeWithGoalAndGap();

function doStats(nums, unit) {
  process.stdout.write(" (ignoring the first half of the data)\n")
  nums = nums.slice(nums.length/2); // Ignore ramp-up measurements;

  var mean = 0;
  nums.forEach(function(num) { mean += num; });
  mean = mean / nums.length;
  process.stdout.write("Mean: " + mean + " " + unit + "\n")

  var variance = 0;
  nums.forEach(function(num) { var diff = num - mean; variance += diff * diff; });
  variance = variance / (nums.length - 1);
  var stdev = Math.sqrt(variance);
  process.stdout.write("Standard deviation: " + stdev + " " + unit + "\n");

  process.stdout.write("\n");
}


function timeBatchSizeWithGoalAndGap() {
  process.stdout.write("Sending " + size + " transactions...");
  var nonceC;

  var sendBatch = lib.ethbase.Account(privkey.toAddress()).nonce.
    then(function(n) { nonceC = n; }).
    then(function() {
      var txList = []
      for (i = 0; i < size; ++i) {
        var tx = lib.ethbase.Transaction({nonce: lib.ethbase.Int(nonceC + i)});
        tx.from = privkey.toAddress();
        tx.sign(privkey);
        txList.push(tx);
      }
      var time0 = process.hrtime();

      return lib.routes.submitTransactionList(txList).
        then(function() { return process.hrtime(time0);}).
        spread(function(durationS, durationNS) {
          var duration = durationS + durationNS / 1e9;
          timesObj.arr.push(duration);
          return duration
        }).
        then(function(duration) {
          process.stdout.write("measured duration: " + duration + "s\n");
        });
    });

  return Promise.delay(gapMS, sendBatch).then(timeBatchSizeWithGoalAndGap);
}
