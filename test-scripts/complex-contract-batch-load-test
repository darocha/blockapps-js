#!/usr/bin/env node
var Promise = require("bluebird");
var lib = require("..");
lib.handlers.enable = true;
//lib.setProfile("ethereum-frontier", "https://strato-scale3.blockapps.net/strato-api");
lib.setProfile("ethereum-frontier", "http://localhost:3000");

var privkey = lib.ethbase.Crypto.PrivateKey.random();
var faucet = lib.routes.faucet(privkey.toAddress());
var account = lib.ethbase.Account(privkey.toAddress());

var size = 100;
var gapMS = 500;
var currentNonce = 0;
var startTime;
var batchesDispatched = 0;

var timesObj = { arr: [] };
process.on('SIGQUIT', function() {
  var sigTimeHR = process.hrtime(startTime);
  var sigTime = sigTimeHR[0] + sigTimeHR[1]/1e9;
  var times = timesObj.arr;
  timesObj.arr = [];

  process.stdout.write("\n\n");

  process.stdout.write("Transmission time stats:");
  doStats(times, "s");

  process.stdout.write("Transmission TPS stats:");
  doStats(times.map(function(time) { return size/time; }), "tx/s");

  process.stdout.write("Total TPS stats:");
  doStats(times.map(function(time) { return size/(time + gapMS / 1000); }), "tx/s");

  var txNum = currentNonce - 1; // Contract creation
  process.stdout.write("Batches dispatched: " + batchesDispatched + "\n");
  process.stdout.write("Transactions executed: " + txNum + "\n");
  process.stdout.write("Transactions executed per second: " + txNum/sigTime + "\n");
  process.stdout.write("Time so far: " + sigTime + "\n");

});

var compileContract = lib.Solidity(`
contract C{
  string[] names;
  mapping (string => int) values;
  
  function C() {
    addName("Alice");
    addName("Bob");
    addName("Carol");
  }

  function addName(string name) {
    names.push(name);
    values[name] = 1;
  }

  function spin() {
    busyWork("Alice");
    busyWork("Bob");
    busyWork("Carol"); 
  }

  function busyWork(string name) {
    for (int i = 0; i < 10; ++i) {
      values[name] *= 2;
    }
  }
}
`).call("construct");

var createContract = faucet.
  thenReturn(compileContract).
  call("callFrom", privkey).
  get("contract");

createContract.tap(function() {
  startTime = process.hrtime();
}).then(timeBatch);

function doStats(nums, unit) {
  process.stdout.write(" (ignoring the first half of the data)\n")
  nums = nums.slice(nums.length/2); // Ignore ramp-up measurements;

  var mean = 0;
  nums.forEach(function(num) { mean += num; });
  mean = mean / nums.length;
  process.stdout.write("Mean: " + mean + " " + unit + "\n")

  var variance = 0;
  nums.forEach(function(num) { var diff = num - mean; variance += diff * diff; });
  variance = variance / (nums.length - 1);
  var stdev = Math.sqrt(variance);
  process.stdout.write("Standard deviation: " + stdev + " " + unit + "\n");

  process.stdout.write("\n");
}

function timeBatch(contract) {
  var sendBatch = account.nonce.
    then(function(n) {
      batchesDispatched++;
      currentNonce = n;
      var txList = [];
      for (i = 0; i < size; ++i) {
        var tx = contract.state.spin().txParams({nonce: n + i, gasLimit: 1000000, gasPrice: 1});
        tx.from = privkey.toAddress();
        tx.sign(privkey);
        txList.push(tx);
      }

      process.stdout.write("# Sending " + size + " transactions\n");

      var time0 = process.hrtime();
      return lib.routes.submitTransactionList(txList).
        tap(function() {
          var durationHR = process.hrtime(time0);
          var duration = durationHR[0] + durationHR[1]/1e9;
          timesObj.arr.push(duration);
          process.stdout.write(duration + "\n");
        });
    });

  return Promise.delay(gapMS, sendBatch).thenReturn(contract).then(timeBatch);
}
