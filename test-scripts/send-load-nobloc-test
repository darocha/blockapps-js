#!/usr/bin/env node
var Promise = require("bluebird");
var lib = require("..");
lib.handlers.enable = true;

var argv = require('minimist')(process.argv.slice(2),
  { default:
    { size: 100
    , gapMS: 3000
    , duration: 10*60 // seconds
    , blocURL: "http://localhost:8000"
    , strato: "http://localhost/strato-api/"
    , profile: "ethereum-frontier"
    , verbose: true
    }
  }
);

var blocURL = argv.blocURL;
var profile = argv.profile;
var strato = argv.strato;
var size = argv.size;
var gapMS = argv.gapMS;
var duration = argv.duration;
var verbose = (argv.verbose == "true");

process.stdout.write("\n");
process.stdout.write("blocURL  " + blocURL + "\n");
process.stdout.write("profile  " + profile + "\n");
process.stdout.write("strato   " + strato + "\n");
process.stdout.write("size     " + size + "\n");
process.stdout.write("gapMS    " + gapMS + "\n");
process.stdout.write("duration " + duration + "\n");
process.stdout.write("verbose  " + verbose + "\n");
process.stdout.write("\n");

lib.setProfile(profile, strato);

var privkey = lib.ethbase.Crypto.PrivateKey.random();
var faucet = lib.routes.faucet(privkey.toAddress());
var account = lib.ethbase.Account(privkey.toAddress());

var currentNonce = 0;
var startTime;
var batchesDispatched = 0;


var statFunction = function () {
  var sigTimeHR = process.hrtime(startTime);
  var sigTime = sigTimeHR[0] + sigTimeHR[1]/1e9;
  var times = timesObj.arr;
  timesObj.arr = [];

  process.stdout.write("======================\n");
  process.stdout.write("batch size " + size + " gapMS " + gapMS + " duration " + duration + " profile " + profile + "\n");
  process.stdout.write("======================\n");
  process.stdout.write("-Transmission time (sec)");
  doStats(times);

  process.stdout.write("-Transmission TPS (tx/sec)");
  doStats(times.map(function(time) { return size/time; }));

  process.stdout.write("-Total TPS (tx/sec)");
  doStats(times.map(function(time) { return size/(time + gapMS / 1000); }));

  var txNum = currentNonce - 1; // Contract creation
  process.stdout.write("*Batches dispatched " + batchesDispatched + "\n");
  process.stdout.write("*Total transactions executed " + txNum + "\n");
  process.stdout.write("*Transactions executed per second " + txNum/sigTime + "\n");
  process.stdout.write("*Time so far " + sigTime + "\n");

  process.stdout.write("======================\n");
  process.exit(0);
};

// var timesObj = { arr: [] };
process.on('SIGQUIT', statFunction);

// If I remove this, I fet handler issues
var compileContract = lib.Solidity(`
contract C{}
`).call("construct");

var createContract = faucet.
  thenReturn(compileContract).
  call("callFrom", privkey).
  get("contract");

var timesObj = { arr: [] };


setInterval(statFunction, duration * 1000);

process.on('unhandledRejection', function(reason, p) {
  console.log('Unhandled Rejection at: Promise', p, 'reason:', reason);
  process.exit(1); 	
});

createContract.tap(function() {
  startTime = process.hrtime();
}).then(timeBatch);

function doStats(nums) {
  process.stdout.write(" (ignoring the first half of the data)\n");
  nums = nums.slice(nums.length/2); // Ignore ramp-up measurements;

  var mean = 0;
  nums.forEach(function(num) { mean += num; });
  mean = mean / nums.length;
  process.stdout.write("mean: " + mean + "\n");

  var variance = 0;
  nums.forEach(function(num) { var diff = num - mean; variance += diff * diff; });
  variance = variance / (nums.length - 1);
  var stdev = Math.sqrt(variance);
  process.stdout.write("stdev: " + stdev + "\n");
  process.stdout.write("\n");
}

function timeBatch(contract) {
  var sendBatch = account.nonce.
    then(function(n) {

      currentNonce = n;
      var totalDispatchedTX = batchesDispatched * size;
      if (verbose) {
        process.stdout.write("nonce before dispatch: " + n + "\n");
        process.stdout.write("total dispatched tx before dispatch: " + totalDispatchedTX + "\n");
      }
      batchesDispatched++;

      var txList = [];
      for (i = 0; i < size; ++i) {
        var tx = lib.ethbase.Transaction({nonce: totalDispatchedTX + 1 + i});
        tx.hash
        tx.from = privkey.toAddress();
        tx.sign(privkey);
        txList.push(tx);
      }

      if (verbose) {
        process.stdout.write("# Sending " + size + " transactions" + " - gap " + gapMS + "\n");
      }

      var time0 = process.hrtime();
      return lib.routes.submitTransactionList(txList).
        tap(function() {
          var durationHR = process.hrtime(time0);
          var duration = durationHR[0] + durationHR[1]/1e9;
          timesObj.arr.push(duration);
          if (verbose) {
            process.stdout.write(duration + "\n");
          }
        });
    });

  return Promise.delay(gapMS, sendBatch).thenReturn(contract).then(timeBatch);
}

